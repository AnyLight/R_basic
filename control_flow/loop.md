# 迴圈結構

### 常見的迴圈結構

以下介紹三種迴圈與兩種改變迴圈狀態的方法。

+ for
+ while
+ repeat
+ break
+ next

```r
> y <- 0
> for (x in c(1:10)) y <- x + y # 1 加到 10，迴圈就是重複執行相同動作，x 依序帶入 1 到 10，第一次帶入 1 時，y = 0，所以是 1 + 0 = 1，第二次帶入時，x = 1，y 已經變成 1，所以變成 1 + 1 = 2，後面一直延續到 x = 10 迴圈就會停止。

> y <- 0
> for (x in c(1:10)) {
+   y <- x + y
+ }

> x <- 1
> y <- 0
> while (x <= 10) { # while 只要符合判斷式，就會一直重複執行括號內程式碼，直到不符合為止。
+   y <- x + y
+   x <- x + 1 # 這行很重要，如果沒有這行，程式碼會一直執行不會停止，因為判斷式是 x 小於等於 10，x 初始值是 0，如果不對 x 做些動作，x 會一直小於等於 10，所以這邊加 1，是希望執行到 x = 11 時，迴圈就會停止。
+ }

> x <- 1
> y <- 0
repeat { # repeat 與 while 有點類似，只是判斷式的部份，可以比較自由寫在括號內任一地方，且跳出迴圈是利用 break 方式。
> repeat {
+   if (x > 10) break # break 是會執行跳出迴圈的動作，
意味程式停止。
+
+   y <- x + y
+   x <- x + 1
+ }

> x <- 1
> y <- 0
> repeat {
+   if (x > 10) { # 此部份判斷式多了一個 x = 5 部份
+     break
+   } else if (x == 5) {
+     x <- x + 1
+     next # next 是指跳過此次的迴圈，執行下一次的迴圈，所以這邊會被跳過 x = 5，代表 5 不會被加到，那有人有疑惑那為何上面要有一個 x <- x + 1，因為跳過 x 還是需要執行加 1 的動作，不然程式只會到 5 不會到 6，想要測試此狀況，就把 x <- x + 1 改成 print(x)，就會發現程式一直跑停不下來。
+   }
+
+   y <- x + y
+   x <- x + 1
+ }
```
